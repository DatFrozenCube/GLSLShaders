<!DOCTYPE html>

<head>
    <title>Example 1</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            text-align: center;
        }

        canvas {
            display: block;
            margin: 20px auto;
            border: 1px solid #ccc;
        }

        h1 {
            color: green;
            margin-top: 20px;
        }

        h3 {
            color: #000000;
            margin-bottom: 20px;
        }
    </style>
</head>

<body onload="start()">
    <h1>GeeksforGeeks</h1>
    <h3>Approach 1: Animated Shader Compilation and Rendering</h3>
    <canvas id="glcanvas" width="640" height="480">
        Oops, your browser does not support the <code>canvas</code> tag.
    </canvas>

    <script type="text/javascript">
        let gl;
        let sId;
        let vBuff;
        let iBuff;
        let timer = 0;

        function initWebGL() {
            let canvas = document.getElementById("glcanvas");
            gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) {
                alert("Unable to initialize WebGL. Your browser may not support it.");
                return;
            }
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            initShaderProgram();
            initBuffers();
        }

        function initShaderProgram() {
            sId = gl.createProgram();
            let vertId = gl.createShader(gl.VERTEX_SHADER);
            let fragId = gl.createShader(gl.FRAGMENT_SHADER);
            let vert = document.getElementById("vertScript").text;
            let frag = document.getElementById("fragScript").text;

            gl.shaderSource(vertId, vert);
            gl.shaderSource(fragId, frag);
            gl.compileShader(vertId);
            gl.compileShader(fragId);
            if (!gl.getShaderParameter(vertId, gl.COMPILE_STATUS)) {
                alert("Vertex Shader Compiler Error: " + gl.getShaderInfoLog(vertId));
                gl.deleteShader(vertId);
                return;
            }
            if (!gl.getShaderParameter(fragId, gl.COMPILE_STATUS)) {
                alert("Fragment Shader Compiler Error: " + gl.getShaderInfoLog(fragId));
                gl.deleteShader(fragId);
                return;
            }
            gl.attachShader(sId, vertId);
            gl.attachShader(sId, fragId);
            gl.linkProgram(sId);
            if (!gl.getProgramParameter(sId, gl.LINK_STATUS)) {
                alert("Shader Linking Error: " + gl.getProgramInfoLog(sId));
            }
        }

        function initBuffers() {
            let vertices = new Float32Array([
                -1.0, -1.0, 0.0,
                -1.0, 1.0, 0.0,
                1.0, 1.0, 0.0,
                1.0, -1.0, 0.0
            ]);
            vBuff = gl.createBuffer()
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuff);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            let indices = new Uint16Array([0, 1, 3, 2]);
            iBuff = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuff);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        }
        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
        })();

        function animationLoop() {
            requestAnimFrame(animationLoop);
            render();
        }

        function render() {
            timer += 0.1;
            gl.useProgram(sId);
            let uID = gl.getUniformLocation(sId, "uTime");
            gl.uniform1f(uID, timer);
            let attId = gl.getAttribLocation(sId, "position");
            gl.enableVertexAttribArray(attId);
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuff);
            gl.vertexAttribPointer(attId, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuff);
            gl.drawElements(gl.TRIANGLE_STRIP, 4, gl.UNSIGNED_SHORT, 0);
        }

        function start() {
            initWebGL();
            animationLoop();
        }
    </script>
    <script id="vertScript" type="x-shader/x-vertex">
        attribute vec3 position; 
        void main(void) {
            gl_Position = vec4(position, 1.0);
        }
    </script>
    <script id="fragScript" type="x-shader/x-fragment">
        precision mediump float;
        uniform float uTime;
        void main(void) {
            vec2 st = gl_FragCoord.xy / vec2(640, 480);
            float r = sin(uTime + 8.0 * 3.14159265359 * st.x);
            float g = fract(sin(3.0 * 3.14159265359 * st.y));   
            float b = sin(uTime + 3.14159265359 * st.x * st.y);
            vec3 color = vec3(r, b, g);
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
</body>

</html>
